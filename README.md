Programming Assignments : Assignment

Unit-1: Introduction to Algorithms: Programming exercises related to implementing and analyzing the efficiency of algorithms for common tasks such as searching and sorting, analyzing the performance of different algorithms using big-O notation and empirical testing, and developing algorithms for specific problems and evaluating their efficiency and effectiveness.

C Programming Exercises:

Implement a binary search algorithm for an array of integers.
Implement a bubble sort algorithm for an array of integers.
Implement a selection sort algorithm for an array of integers.
Implement an insertion sort algorithm for an array of integers.
Implement a merge sort algorithm for an array of integers.
Implement a quick sort algorithm for an array of integers.
Implement a linear search algorithm for an array of integers.
Implement a hash table data structure using separate chaining collision resolution.
Implement a hash table data structure using linear probing collision resolution.
Implement a heap data structure and use it to sort an array of integers.
Python Programming Exercises:

Implement a binary search algorithm for a list of integers.

Implement a bubble sort algorithm for a list of integers.

Implement a selection sort algorithm for a list of integers.

Implement an insertion sort algorithm for a list of integers.

Implement a merge sort algorithm for a list of integers.

Implement a quick sort algorithm for a list of integers.

Implement a linear search algorithm for a list of integers.

Implement a hash table data structure using separate chaining collision resolution.

Implement a hash table data structure using linear probing collision resolution.

Implement a heap data structure and use it to sort a list of integers.

Flowchart Exercises:

Create a flowchart for a binary search algorithm.

Create a flowchart for a bubble sort algorithm.

Create a flowchart for a selection sort algorithm.

Create a flowchart for an insertion sort algorithm.

Create a flowchart for a merge sort algorithm.

Create a flowchart for a quick sort algorithm.

Create a flowchart for a linear search algorithm.

Create a flowchart for a hash table data structure using separate chaining collision resolution.

Create a flowchart for a hash table data structure using linear probing collision resolution.

Create a flowchart for a heap data structure and use it to sort an array of integers.

These exercises can help you practice and develop your skills in implementing and analyzing the efficiency of algorithms for common tasks such as searching and sorting, analyzing the performance of different algorithms using big-O notation and empirical testing, and developing algorithms for specific problems and evaluating their efficiency and effectiveness.

Unit-2: Divide and Conquer: Complete following programming exercises related to implementing and analyzing the efficiency of divide-and-conquer algorithms for specific problems, developing new divide-and-conquer algorithms for complex problems and evaluating their efficiency and effectiveness, and comparing and contrasting divide-and-conquer algorithms with other algorithmic approaches.

C Programming Exercises:

Implement a recursive algorithm for computing the factorial of a given positive integer using divide-and-conquer.
Implement a recursive algorithm for computing the Fibonacci sequence using divide-and-conquer.
Implement a recursive algorithm for computing the greatest common divisor of two integers using divide-and-conquer.
Implement a recursive algorithm for computing the Euclidean distance between two points in 2D space using divide-and-conquer.
Implement a divide-and-conquer algorithm for finding the maximum subarray sum of a given array of integers.
Implement a divide-and-conquer algorithm for merging two sorted arrays.
Implement a divide-and-conquer algorithm for finding the kth largest element in an unsorted array of integers.
Implement a divide-and-conquer algorithm for multiplying two large integers.
Implement a divide-and-conquer algorithm for finding the closest pair of points in 2D space.
Implement a divide-and-conquer algorithm for sorting a linked list.
Python Programming Exercises:

Implement a recursive algorithm for computing the factorial of a given positive integer using divide-and-conquer.
Implement a recursive algorithm for computing the Fibonacci sequence using divide-and-conquer.
Implement a recursive algorithm for computing the greatest common divisor of two integers using divide-and-conquer.
Implement a recursive algorithm for computing the Euclidean distance between two points in 2D space using divide-and-conquer.
Implement a divide-and-conquer algorithm for finding the maximum subarray sum of a given array of integers.
Implement a divide-and-conquer algorithm for merging two sorted arrays.
Implement a divide-and-conquer algorithm for finding the kth largest element in an unsorted array of integers.
Implement a divide-and-conquer algorithm for multiplying two large integers.
Implement a divide-and-conquer algorithm for finding the closest pair of points in 2D space.
Implement a divide-and-conquer algorithm for sorting a linked list.
Flowchart Exercises:

Create a flowchart for a recursive algorithm for computing the factorial of a given positive integer using divide-and-conquer.
Create a flowchart for a recursive algorithm for computing the Fibonacci sequence using divide-and-conquer.
Create a flowchart for a recursive algorithm for computing the greatest common divisor of two integers using divide-and-conquer.
Create a flowchart for a recursive algorithm for computing the Euclidean distance between two points in 2D space using divide-and-conquer.
Create a flowchart for a divide-and-conquer algorithm for finding the maximum subarray sum of a given array of integers.
Create a flowchart for a divide-and-conquer algorithm for merging two sorted arrays.
Create a flowchart for a divide-and-conquer algorithm for finding the kth largest element in an unsorted array of integers.
Create a flowchart for a divide-and-conquer algorithm for multiplying two large integers.
Create a flowchart for a divide-and-conquer algorithm for finding the closest pair of points in 2D space.
Create a flowchart for a divide-and-conquer algorithm for sorting a linked list.
These exercises can help you practice and develop your skills in implementing and analyzing the efficiency of divide-and-conquer algorithms for specific problems, developing new divide-and-conquer algorithms for complex problems and evaluating their efficiency and effectiveness, and comparing and contrasting divide-and-conquer algorithms with other algorithmic approaches.

Unit-3: Dynamic Programming:

C/Python /Flowchart

Implement the Fibonacci sequence using dynamic programming in C or Python. Analyze the time complexity of your implementation and compare it with the time complexity of a recursive implementation.

Implement the longest common subsequence problem using dynamic programming in C or Python. Analyze the time and space complexity of your implementation and compare it with the time and space complexity of a naive recursive implementation.

Implement the knapsack problem using dynamic programming in C or Python. Analyze the time and space complexity of your implementation and compare it with the time and space complexity of a greedy algorithm.

Implement the rod-cutting problem using dynamic programming in C or Python. Analyze the time and space complexity of your implementation and compare it with the time and space complexity of a naive recursive implementation.

Implement the matrix chain multiplication problem using dynamic programming in C or Python. Analyze the time and space complexity of your implementation and compare it with the time and space complexity of a naive recursive implementation.

Develop a dynamic programming algorithm for the edit distance problem in C or Python. Analyze the time and space complexity of your implementation and compare it with the time and space complexity of a naive recursive implementation.

Develop a dynamic programming algorithm for the coin change problem in C or Python. Analyze the time and space complexity of your implementation and compare it with the time and space complexity of a greedy algorithm.

Implement a dynamic programming algorithm to find the maximum sum subarray in C or Python. Analyze the time and space complexity of your implementation and compare it with the time and space complexity of a naive brute-force approach.

Develop a dynamic programming algorithm to find the longest increasing subsequence in C or Python. Analyze the time and space complexity of your implementation and compare it with the time and space complexity of a brute-force approach.

Create a flowchart for a dynamic programming algorithm that solves the longest common substring problem. Analyze the time and space complexity of the algorithm and compare it with the time and space complexity of a brute-force approach. These exercises will help you understand and implement dynamic programming algorithms, analyze their time and space complexity, and compare them with other algorithmic approaches.

Unit-4: Greedy Algorithms:

C/Python /Flowchart

Implement the Huffman coding algorithm to compress a given string in C or Python.

Implement Kruskal's algorithm to find the minimum spanning tree of a given graph in C or Python.

Implement the Dijkstra algorithm to find the shortest path between two vertices in a graph in C or Python.

Implement the activity selection problem using a greedy approach in C or Python.

Implement the knapsack problem using a greedy approach in C or Python.

Implement the coin change problem using a greedy approach in C or Python.

Develop a new greedy algorithm to solve the job scheduling problem and analyze its efficiency and effectiveness in C or Python.

Implement Prim's algorithm to find the minimum spanning tree of a given graph in flowchart.

Implement the interval scheduling problem using a greedy approach in flowchart.

Implement the fractional knapsack problem using a greedy approach in flowchart.

These exercises will help you practice implementing and analyzing the efficiency of greedy algorithms for specific problems, developing new greedy algorithms for complex problems, and comparing and contrasting greedy algorithms with other algorithmic approaches.

Unit-5: Graph Algorithms:

C/Python /Flowchart

Implement Breadth First Search (BFS) algorithm to find the shortest path between two nodes in a graph in C or Python.

Implement Depth First Search (DFS) algorithm to traverse a graph and find connected components in C or Python.

Implement Dijkstra's algorithm to find the shortest path between two nodes in a weighted graph in C or Python.

Implement Bellman-Ford algorithm to find the shortest path between two nodes in a graph with negative weight edges in C or Python.

Implement the Floyd-Warshall algorithm to find the shortest path between all pairs of nodes in a graph in C or Python.

Implement the Prim's algorithm to find the minimum spanning tree of a given graph in C or Python.

Develop a new graph algorithm to solve the traveling salesman problem and evaluate its efficiency and effectiveness in C or Python.

Implement the PageRank algorithm to rank web pages in a network in Python.

Implement the Girvan-Newman algorithm to find communities in a social network in Python.

Apply graph algorithms to analyze the network structure and connectivity of a real-world social network, such as Facebook or Twitter.

These exercises will help you practice implementing and analyzing the efficiency of graph algorithms for specific problems, developing new graph algorithms for complex problems, and applying graph algorithms to real-world problems such as network analysis and social network analysis.

Unit-6 :NP-Completeness:

C/Python /Flowchart

Implement a dynamic programming algorithm for the Longest Common Subsequence Problem (LCS), and analyze its time and space complexity using Big-O notation.

Develop a greedy algorithm for the Job Scheduling Problem, and evaluate its effectiveness on a variety of input instances.

Implement a branch and bound algorithm for the Traveling Salesman Problem, and analyze its running time complexity.

Develop an approximation algorithm for the Set Cover Problem, and analyze its approximation ratio and running time complexity.

Implement a genetic algorithm for the Knapsack Problem, and evaluate its performance on a set of large-scale instances.

Develop a local search algorithm for the Maximum Cut Problem, and compare its performance to that of a randomized algorithm on a set of random graphs.

Implement a randomized algorithm for the Vertex Cover Problem, and analyze its expected running time using probabilistic techniques.

Develop an approximation algorithm for the Steiner Tree Problem, and analyze its approximation ratio and running time complexity.

Implement a simulated annealing algorithm for the Graph Coloring Problem, and evaluate its performance on a set of benchmark instances.

Develop a heuristic algorithm for the Maximum Clique Problem, and compare its performance to that of the exact algorithm on a set of benchmark instances.

Implement a brute force algorithm for the Traveling Salesman Problem (TSP), and analyze its time complexity using Big-O notation.

Develop an approximation algorithm for the Vertex Cover Problem, and evaluate its effectiveness on a variety of input graphs.

Implement a greedy algorithm for the Knapsack Problem, and analyze its approximation ratio.

Develop a heuristic algorithm for the Maximum Clique Problem, and compare its performance to that of the exact algorithm on a set of benchmark instances.

Implement a randomized algorithm for the Subset Sum Problem, and analyze its expected running time using probabilistic techniques.

Develop a genetic algorithm for the Quadratic Assignment Problem, and evaluate its performance on a set of large-scale instances.

Implement a local search algorithm for the Graph Coloring Problem, and compare its performance to that of a randomized algorithm on a set of randomly generated graphs.

Develop an approximation algorithm for the Set Cover Problem, and analyze its approximation ratio and running time complexity.

Implement a simulated annealing algorithm for the Traveling Salesman Problem, and evaluate its performance on a set of benchmark instances.

Develop a tabu search algorithm for the Maximum Cut Problem, and compare its performance to that of a greedy algorithm on a set of random graphs.
